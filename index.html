<!DOCTYPE html>
<html>
<head>
	<!-- <script lang="javascript" src="assets/js/jquery-3.1.0.min.js"></script> -->
	<script lang="javascript" src="assets/js/d3.v4.min.js"></script>
	<link rel="stylesheet" href="assets/css/bar.css"/>
	<style>
		svg { font:10px sans-serif; }
		rect { stroke: #fff; }
	</style>
</head>
<body>
	<!-- <svg id="barchart"></svg> -->

	<script>

	// set the dimensions and margins of the graph
	var margin = {top: 20, right: 20, bottom: 80, left: 40},
	    width = 1500 - margin.left - margin.right,
	    height = 800 - margin.top - margin.bottom,
		padding = 25,
		GROUP_SEPARATION_RATE = 2;

	// set the ranges
	var x = d3.scaleBand()
	          .range([0, width])
	          .padding(0.1);
	var y = d3.scaleLinear()
	          .range([height, 0]);
	
	var svg = d3.select("body").append("svg")
	    .attr("width", width + margin.left + margin.right)
	    .attr("height", height + margin.top + margin.bottom)
	
	var group = svg.append("g")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")")

	function filterIncident(data) {
		let fatalities = []
		let injuries = []
		let res = []
		data.forEach(function(element) {
			fatalities.push(element["fatalities"])
			injuries.push(element["injured"])
		});
		res[0] = fatalities
		res[1] = injuries
		return res
	}

	let csv_file = "/assets/data/mass_shootings.csv";
	if (location.hostname != "localhost")
		csv_file = "/viz_mass_shootings" + csv_file
	
	console.log(csv_file)

	d3.queue()
	  .defer(d3.csv, csv_file)
	  .await(ready);

	const MAX_DOMAIN = 100
	const AXIS_TEXT_DY = ".80em"

	function ready(error, data) {
		if (error) { console.log(error); }
		let STATE = "default";
		let ACTUAL_MAX_DOMAIN = d3.max(data, d => { return Number(d.total_victims); })


		let years_to_idx = getYearToIdx(data)
		const numYears = Object.keys(years_to_idx).length
		/* SCALES */
		var yScale = d3.scaleLinear()
		.domain([0, MAX_DOMAIN])// ])
		.range([height, 0]);
		
		var parseTime = d3.timeParse("%m/%d/%Y"), parseYear = d3.timeParse("%Y");
		var yearRange = [parseYear("1982"), parseYear("2019")]
		var xTimeScale = d3.scaleTime()
			.domain(yearRange)
			.range([0, width])

		var xDistributedScale = d3.scaleLinear()
			.domain([0, data.length + (numYears)*GROUP_SEPARATION_RATE])
			.range([0, width])

		/* AXES */
		var yAxis = d3.axisLeft(yScale)
			.ticks(10)
			.tickSize(5, 0, 0)
			.tickFormat(d => {return d})

		var xAxis = d3.axisBottom(xTimeScale)
			.ticks(20)

		let distributed_domain_values = Object.keys(years_to_idx).map(year => {
			let d = years_to_idx[year];
			return d.first_bar_idx + d.num/2.0 + d.idx * GROUP_SEPARATION_RATE
		});
		var xDistributedAxis = d3.axisBottom(xDistributedScale)
			.tickValues(distributed_domain_values)
			.tickFormat((d, i) => {return Object.keys(years_to_idx)[i]})
		
		var zoom = d3.zoom()
			.scaleExtent([1, 15])
			.translateExtent([[0, 0], [width, height]])
			.extent([[0, 0], [width, height]])
			.on("zoom", zoomed);
	
		// function zoomed() {
		// 	var t = d3.event.transform;
		// 	xTimeScale.domain(t.rescaleX(xTimeScale).domain());
		// 	d3.select(".x_axis").call(xAxis);
		// }
		function zoomed() {
			if (STATE != "default") return;
			let new_xScale = d3.event.transform.rescaleX(xTimeScale).range([0, width]);
			
			group.select(".x_axis").transition()
				.duration(20)
				.call(xAxis.scale(new_xScale))
				.selectAll("text")	
				.style("text-anchor", "end")
				.attr("dx", "-.8em")
				.attr("dy", AXIS_TEXT_DY)
				.attr("transform", "rotate(-65)");		
			
			group.selectAll("rect").transition()
				.duration(20)
				.attr("x", (d, i) => {let newx = new_xScale(parseTime(d.date)); return newx >= 0? newx <= width? newx: width+10000: -10000})
		}

		svg.call(zoom);

		/* SVG APPENDAGES */
		var groups = group.selectAll("g")
			.data(data).enter()
			.append("g")
			.attr("class", "bar")
			.attr("id", (d, i) => {return "g_" + i});
		
		groups
			.append("rect")
			.attr("class", "blackbars")
			.attr("id", (d, i) => {return "black_" + i})
			.attr("x", (d, i) => {return xTimeScale(parseTime(d.date))})
			.attr("y", (d) => {return yScale(d.total_victims)})
			.attr("width", 5)
			.attr("height", (d) => {return height - yScale(d.total_victims)})
			.style("fill", "black")
		
		groups
			.append("rect")
			.attr("class", "redbars")
			.attr("id", (d, i) => {return "red_" + i})
			.attr("x", (d, i) => {return xTimeScale(parseTime(d.date))})
			.attr("y", (d) => {return yScale(d.fatalities)})
			.attr("width", 5)
			.attr("height", (d) => {return height - yScale(d.fatalities)})
			.style("fill", "red")
		
		group.append("g")
			.attr("class", "y_axis")
			.call(yAxis);

		group.append("g")
			.attr("class", "x_axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis)
			.selectAll("text")	
			.style("text-anchor", "end")
			.attr("dx", "-.8em")
			.attr("dy", AXIS_TEXT_DY)
			.attr("transform", "rotate(-65)");

		/* VIEW CONVERSION FUNCTIONS */
		let convertToDistributed = () => {
			STATE = "distrubuted";
			d3.selectAll(".blackbars")
				.transition()
				.duration(600)
				.attr('x', (d, i) => {
					return xDistributedScale(i + years_to_idx[d.year].idx * GROUP_SEPARATION_RATE);
				})
				.attr('width', 9)
			d3.selectAll(".redbars")
				.transition()
				.duration(600)
				.attr('x', (d, i) => {
					return xDistributedScale(i + years_to_idx[d.year].idx * GROUP_SEPARATION_RATE);
				})
				.attr('width', 9)
			
			d3.select(".x_axis").call(xDistributedAxis)
				.selectAll("text")	
				.style("text-anchor", "end")
				.attr("dx", "-.8em")
				.attr("dy", AXIS_TEXT_DY)
				.attr("transform", "rotate(-65)");
		}

		let convertToYearly = () => {
			STATE = "default";

			d3.selectAll(".blackbars")
				.transition()
				.duration(600)
				.attr('x', (d, i) => {return xTimeScale.domain(yearRange)(parseTime(d.date))})
				.attr('width', 5)
			d3.selectAll(".redbars")
				.transition()
				.duration(600)
				.attr('x', (d, i) => {return xTimeScale(parseTime(d.date))})
				.attr('width', 5)

			d3.select(".x_axis").call(xAxis.scale(xTimeScale))
				.selectAll("text")	
				.style("text-anchor", "end")
				.attr("dx", "-.8em")
				.attr("dy", AXIS_TEXT_DY)
				.attr("transform", "rotate(-65)");
		}

		y_axis_cutoff = true;
		let scaleYAxis = () => {
			let domain = y_axis_cutoff? ACTUAL_MAX_DOMAIN: MAX_DOMAIN;
			let newYscale = yScale.domain([0, domain]);
			y_axis_cutoff = !y_axis_cutoff;

			d3.selectAll(".blackbars")
				.transition()
				.duration(600)
				.attr('y', (d, i) => {return newYscale(d.total_victims)})
				.attr("height", (d) => {return height - newYscale(d.total_victims)})
			
			d3.selectAll(".redbars")
				.transition()
				.duration(600)
				.attr('y', (d, i) => {return newYscale(d.fatalities)})
				.attr("height", (d) => {return height - newYscale(d.fatalities)})

			d3.select(".y_axis").transition().duration(600).call(yAxis.scale(newYscale));
		}

		/* BUTTONS */
		svg.append("rect")
			.attr("x", 100)
			.attr("y", 100)
			.attr("width", 75)
			.attr("height", 75)
			.style("fill", "blue")
			.on("click", convertToDistributed);

		svg.append("rect")
			.attr("x", 185)
			.attr("y", 100)
			.attr("width", 75)
			.attr("height", 75)
			.style("fill", "green")
			.on("click", convertToYearly);
		
		svg.append("rect")
			.attr("x", 192)
			.attr("y", 40)
			.attr("width", 50)
			.attr("height", 50)
			.style("fill", "black")
			.on("click", scaleYAxis);
	}

	function getYearlyVictims(data) {
		let yearlyVictims = {}
		data.forEach(function(element) {
			let year = (new Date(element["date"])).getFullYear()
			if (year in yearlyVictims) {
				yearlyVictims[year] += Number(element["total_victims"])
			} else {
				yearlyVictims[year] = Number(element["total_victims"])
			}
		})
		return yearlyVictims
	}

		function getYearToIdx(data) {
			let yearlyVictims = {}
			let counter = 0
			let num_element = 0
			data.reverse().forEach(function(element) {
				let year = (new Date(element["date"])).getFullYear()
				if (!(year in yearlyVictims)) {
					yearlyVictims[year] = {
						idx: counter++,
						num: 1,
						first_bar_idx: num_element,
						year: year
					};
				} else {
					yearlyVictims[year].num++;
				}
				num_element++;
			})
			return yearlyVictims
		}

	</script>

</body>
</html>