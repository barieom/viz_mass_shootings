<!DOCTYPE html>
<html>
<head>
	<!-- <script lang="javascript" src="assets/js/jquery-3.1.0.min.js"></script> -->
	<script lang="javascript" src="assets/js/d3.v4.min.js"></script>
	<link rel="stylesheet" href="assets/css/bar.css"/>
	<style>
		svg { font:10px sans-serif; }
		rect { stroke: #fff; }
	</style>
</head>
<body>
	<!-- <svg id="barchart"></svg> -->

	<script>

	// set the dimensions and margins of the graph
	var margin = {top: 20, right: 20, bottom: 30, left: 40},
	    width = 1500 - margin.left - margin.right,
	    height = 800 - margin.top - margin.bottom,
		padding = 25,
		GROUP_SEPARATION_RATE = 2;

	// set the ranges
	var x = d3.scaleBand()
	          .range([0, width])
	          .padding(0.1);
	var y = d3.scaleLinear()
	          .range([height, 0]);

	// https://bl.ocks.org/d3noob/bdf28027e0ce70bd132edc64f1dd7ea4
	          
	// append the svg object to the body of the page
	// append a 'group' element to 'svg'
	// moves the 'group' element to the top left margin
	var svg = d3.select("body").append("svg")
	    .attr("width", width + margin.left + margin.right)
	    .attr("height", height + margin.top + margin.bottom)
		.append("g")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
	//   .append("g")
	//     .attr("transform", 
	//           "translate(" + margin.left + "," + margin.top + ")");

	function filterIncident(data) {
		let fatalities = []
		let injuries = []
		let res = []
		data.forEach(function(element) {
			fatalities.push(element["fatalities"])
			injuries.push(element["injured"])
		});
		res[0] = fatalities
		res[1] = injuries
		return res
	}


	d3.queue()
	  .defer(d3.csv, "/assets/data/mass_shootings.csv")
	  .await(ready);

	const MAX_DOMAIN = 100

	function ready(error, data) {
		if (error) { console.log(error); }

		let years_to_idx = getYearToIdx(data)
		const numYears = Object.keys(years_to_idx).length
		console.log(years_to_idx)
		console.log(numYears)
		
		/* SCALES */
		var yScale = d3.scaleLinear()
		.domain([0, MAX_DOMAIN])//d3.max(data, d => { return Number(d.total_victims); })])
		.range([height, 0]);
		
		var parseTime = d3.timeParse("%m/%d/%Y");
		var parseYear = d3.timeParse("%Y");

		var xTimeScale = d3.scaleTime()
			.domain([parseYear("1982"), parseYear("2019")])
			.range([0, width])

		var xDistributedScale = d3.scaleLinear()
			.domain([0, data.length + (numYears)*GROUP_SEPARATION_RATE])
			.range([0, width])

		/* AXES */
		var yAxis = d3.axisLeft(yScale)
			.ticks(10)
			.tickSize(5, 0, 0)
			.tickFormat(d => {return d})

		var xAxis = d3.axisBottom(xTimeScale)
			.tickFormat(d3.timeFormat("%m-%Y"))
			.ticks(20)

		let distributed_domain_values = Object.keys(years_to_idx).map(year => {
			let d = years_to_idx[year];
			return d.first_bar_idx + d.num/2.0 + d.idx * GROUP_SEPARATION_RATE
		})
		var xDistributedAxis = d3.axisBottom(xDistributedScale)
			.tickValues(distributed_domain_values)
			.tickFormat((d, i) => {return Object.keys(years_to_idx)[i]})

		/* SVG APPENDAGES */
		var groups = svg.selectAll("g")
			.data(data).enter()
			.append("g")
			.attr("class", "bar")
			.attr("id", (d, i) => {return "g_" + i});
		
		groups
			.append("rect")
			.attr("class", "blackbars")
			.attr("id", (d, i) => {return "black_" + i})
			.attr("x", (d, i) => {return xTimeScale(parseTime(d.date))})
			.attr("y", (d) => {return yScale(d.total_victims)})
			.attr("width", 5)
			.attr("height", (d) => {return height - yScale(d.total_victims)})
			.style("fill", "black")
		
		groups
			.append("rect")
			.attr("class", "redbars")
			.attr("id", (d, i) => {return "red_" + i})
			.attr("x", (d, i) => {return xTimeScale(parseTime(d.date))})
			.attr("y", (d) => {return yScale(d.fatalities)})
			.attr("width", 5)
			.attr("height", (d) => {return height - yScale(d.fatalities)})
			.style("fill", "red")
		
		svg.append("g")
			.attr("class", "y_axis")
			.call(yAxis);

		svg.append("g")
			.attr("class", "x_axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis)
			.selectAll("text")	
			.style("text-anchor", "end")
			.attr("dx", "-.8em")
			.attr("dy", ".15em")
			.attr("transform", "rotate(-65)");
		
		var zoom = d3.zoom().on('zoom', () => {
			let new_xScale = d3.event.transform.rescaleX(xScale);
			console.log(xScale(50))
			console.log(new_xScale)
		});

		/* VIEW CONVERSION FUNCTIONS */
		let convertToDistributed = () => {
			d3.selectAll(".blackbars")
				.transition()
				.duration(600)
				.attr('x', (d, i) => {
					return xDistributedScale(i + years_to_idx[d.year].idx * GROUP_SEPARATION_RATE);
				})
				.attr('width', 8)
			d3.selectAll(".redbars")
				.transition()
				.duration(600)
				.attr('x', (d, i) => {
					return xDistributedScale(i + years_to_idx[d.year].idx * GROUP_SEPARATION_RATE);
				})
				.attr('width', 8)
			
			d3.select(".x_axis").call(xDistributedAxis)
				.selectAll("text")	
				.style("text-anchor", "end")
				.attr("dx", "-.8em")
				.attr("dy", ".15em")
				.attr("transform", "rotate(-65)");
		}

		let convertToYearly = () => {
			d3.selectAll(".blackbars")
				.transition()
				.duration(600)
				.attr('x', (d, i) => {return xTimeScale(parseTime(d.date))})
				.attr('width', 5)
			d3.selectAll(".redbars")
				.transition()
				.duration(600)
				.attr('x', (d, i) => {return xTimeScale(parseTime(d.date))})
				.attr('width', 5)

			d3.select(".x_axis").call(xAxis)
				.selectAll("text")	
				.style("text-anchor", "end")
				.attr("dx", "-.8em")
				.attr("dy", ".15em")
				.attr("transform", "rotate(-65)");
		}

		svg.append("rect")
			.attr("x", 100)
			.attr("y", 100)
			.attr("width", 50)
			.attr("height", 50)
			.style("fill", "blue")
			.on("click", convertToDistributed);

		svg.append("rect")
			.attr("x", 160)
			.attr("y", 100)
			.attr("width", 50)
			.attr("height", 50)
			.style("fill", "green")
			.on("click", convertToYearly);
	}

	function getYearlyVictims(data) {
		let yearlyVictims = {}
		data.forEach(function(element) {
			let year = (new Date(element["date"])).getFullYear()
			if (year in yearlyVictims) {
				yearlyVictims[year] += Number(element["total_victims"])
			} else {
				yearlyVictims[year] = Number(element["total_victims"])
			}
		})
		return yearlyVictims
	}

		function getYearToIdx(data) {
			let yearlyVictims = {}
			let counter = 0
			let num_element = 0
			data.reverse().forEach(function(element) {
				let year = (new Date(element["date"])).getFullYear()
				if (!(year in yearlyVictims)) {
					yearlyVictims[year] = {
						idx: counter++,
						num: 1,
						first_bar_idx: num_element,
						year: year
					};
				} else {
					yearlyVictims[year].num++;
				}
				num_element++;
			})
			return yearlyVictims
		}

	</script>

</body>
</html>